public class Main {

//    Задание 1. Ответьте письменно на вопросы:
//
//            1)  Почему использование тестовых заглушек может быть полезным при написании модульных тестов?
//                  -упрощает тестирование
//                  -тестовые заглушки могут передаваться вместо реальных зависимостей,что увеличивает скорость проверки
//                  -снижает сложность тестов
//                  - код  можно проверять независимо от остальной системы
//
//
//            2) Какой тип тестовой заглушки следует использовать, если вам нужно проверить, что метод был вызван с определенными аргументами? - Dummy
//
//            3) Какой тип тестовой заглушки следует использовать, если вам просто нужно вернуть определенное значение или исключение в ответ на вызов метода? -  Stub
//
//            4) Какой тип тестовой заглушки вы бы использовали для имитации  взаимодействия с внешним API или базой данных? - Mock
//
//    Задание 2.
//
//    У вас есть класс BookService, который использует интерфейс BookRepository для получения информации о книгах
//    из базы данных. Ваша задача написать unit-тесты для BookService, используя Mockito для создания мок-объекта BookRepository.

}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//                     1.Dummy - фиктивный объект.
//                     * Тестовая заглушка (фиктивный объект)- это такой объект,который передается в тестируему систему в качестве аргумента,
//                    но при этом сам не выполняет никакой активной функциональности. Тоесть просто используется для запонения параметров, методов или функций в тестах.
//                    Служит для того,чтобы закрыть дыру.(Просто,чтобы была заглушка,не имеет значение какой создали объект - это не важно)
//                     * Отличие от другиих заглушек заключается в том,что заглушка(фиктивный объект) имеет нулевую функциональность,
//                    тоесть фиктивные объекты не имеюют никаких ответов на вызовы методов и не записывают информацию о взаимодействии, тоесть эжто просто какаято пустая сущность.
//                     * Чаще всего используются  в тех случаях, когда нужно передать какие либо аргументы в тестируемую функцию.

//                    2.Stub
//                     * Заменяет реальный компонент, от которого зависит наша тестируемая система, но при этом она представляет уже заранее
//                       определенные ответы на вызовы методов этих компонентов.(Хотим чтобы заглушка возвращала конкретный результат
////                     и тест просиходил с этим конкретным результатом)
//                     * Отличие от другиих заглушек заключается в том,что заглушка представляет уже фиксированный результат
//                    тоесть эти заглушки не проверяют,какие методы были вызваны. Она просто возвращает уже заданное ей значение.
//                     * Чаще всего используются  в тех случаях, когда необходимо изолировать тестируемую систему от реальных зависимостей
//                     и предоставить конкретный контролируемый нами написанный(кем то придуманный) результат.

//                    3.Mock = имитация (все названия заглушек в себе хранят ответ на использование этой заглушки)
//                     * Заменяет уже реальный компонент (дублирует), но при этом  представляет  более гибкий контроль над поведением этого объекта .
//                      Позволяют проверять вызовы метода, имитировать различные сценарии взаимодействия.
//                     * Отличие от другиих заглушек заключается в том,что заглушка активно проверяет вызовы методов и их аргументов, и имитирет объект
//                       Имитация представляет более высокий уровень абстракции и гибкости.
//                     * Чаще всего используются  в тех случаях, когда необходимо более подробное гибкое глубокое тестирование и взаимодействие между компонентами.
//                        mock - единственный позволяет проверить, что методы вызываются с ожидаемыми аргументами и в правильном порядке.(подмена поведения, работают намного быстрее)
//                          1.создает класс намного быстреее, чем мы создавали обычный класс
//                          2.клонирует класс, а не создает реальный класс
//                          3.дополнительная функциональность с разными методами









